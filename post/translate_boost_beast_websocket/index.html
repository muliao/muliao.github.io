<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Muliao&#39;s Blog  | 翻译boost.beast websocket部分文档</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.59.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="翻译boost.beast websocket部分文档" />
<meta property="og:description" content="简介

准备使用boost.beast库的websocket,边看文档边翻译，在此记录下。

使用的是boost 1_68_0版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://muliao.github.io/post/translate_boost_beast_websocket/" />
<meta property="article:published_time" content="2019-11-20T17:07:04+08:00" />
<meta property="article:modified_time" content="2019-11-20T17:07:04+08:00" />
<meta itemprop="name" content="翻译boost.beast websocket部分文档">
<meta itemprop="description" content="简介

准备使用boost.beast库的websocket,边看文档边翻译，在此记录下。

使用的是boost 1_68_0版本">


<meta itemprop="datePublished" content="2019-11-20T17:07:04&#43;08:00" />
<meta itemprop="dateModified" content="2019-11-20T17:07:04&#43;08:00" />
<meta itemprop="wordCount" content="3986">



<meta itemprop="keywords" content="boost,beast,翻译,websocket,c&#43;&#43;," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="翻译boost.beast websocket部分文档"/>
<meta name="twitter:description" content="简介

准备使用boost.beast库的websocket,边看文档边翻译，在此记录下。

使用的是boost 1_68_0版本"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-blue">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://muliao.github.io" class="f3 fw2 hover-white no-underline white-90 dib">
      Muliao&#39;s Blog
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="About page">
              About
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="About page">
              About
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/post/" title="Articles page">
              Articles
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/contact/" title="Contact page">
              Contact
            </a>
          </li>
          
        </ul>
      
      












    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        ARTICLES
      </p>
      <h1 class="f1 athelas mb1">翻译boost.beast websocket部分文档</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-11-20T17:07:04&#43;08:00">November 20, 2019</time>
      
      
        <span class="f6 mv4 dib tracked"> - 19 minutes read</span>
        <span class="f6 mv4 dib tracked"> - 3986 words</span>
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="简介">简介</h2>

<p>准备使用boost.beast库的websocket,边看文档边翻译，在此记录下。</p>

<p>使用的是boost 1_68_0版本</p>

<style>
cn {color:rgb(200,200,200);}
</style>

<h2 id="using-websocket-cn-使用websocket-cn">Using WebSocket <cn>使用WebSocket</cn></h2>

<p>The WebSocket Protocol enables two-way communication between a client running untrusted code in a controlled environment to a remote host that has opted-in to communications from that code.<br>
<cn>WebSocket协议允许在受控环境中运行不受信任的代码的客户端与已选择从该代码进行通信的远程主机之间进行双向通信。</cn><br>
The protocol consists of an opening handshake followed by basic message framing, layered over TCP.<br>
<cn>该协议包括一个开放的握手，随后是基于TCP分层的基本消息框架。</cn><br>
The goal of this technology is to provide a mechanism for browser-based applications needing two-way communication with servers without relying on opening multiple HTTP connections.<br>
<cn>该技术的目标是为需要与服务器进行双向通信的基于浏览器的应用程序提供一种机制，而无需依赖于打开多个HTTP连接。</cn></p>

<p>Beast provides developers with a robust WebSocket implementation built on Boost.Asio with a consistent asynchronous model using a modern C++ approach.<br>
<cn>Beast使用现代C ++方法为开发人员提供了基于Boost.Asio的可靠WebSocket实现，并具有一致的异步模型。</cn></p>

<blockquote>
<p>Note<br>
This documentation assumes familiarity with Boost.Asio and the protocol specification described in rfc6455. <br>
<cn>本文档假定您熟悉Boost.Asio 和rfc6455中描述的协议规范。</cn><br>
Sample code and identifiers appearing in this section is written as if these declarations are in effect:<br>
<cn>本节中出现的示例代码和标识符的编写方式就像这些声明有效一样：</cn></p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/beast/websocket.hpp&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> boost<span style="color:#f92672">::</span>beast<span style="color:#f92672">::</span>websocket;
</code></pre></div>
<h2 id="creating-streams-cn-创建流-cn">Creating Streams <cn>创建流</cn></h2>

<p>The interface to the WebSocket implementation is a single template class stream:<br>
<cn>WebSocket实现的接口是单个模板类 stream：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// A WebSocket stream
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>
    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NextLayer</span>,
    <span style="color:#66d9ef">bool</span> deflateSupported <span style="color:#f92672">=</span> true<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">stream</span>;
</code></pre></div>
<p>An instance of the stream wraps an existing network transport object or other type of octet oriented stream. <br>
<cn>流的实例包装现有的网络传输对象或其他类型的面向八位字节的流。</cn><br>
The wrapped object is called the &ldquo;next layer&rdquo; and must meet the requirements of SyncStream if synchronous operations are performed, AsyncStream if asynchronous operations are performed, or both. <br>
<cn>被包装的对象被称为“next layer”,如果执行同步操作的话还必须满足的SyncStream的要求, 异步的话要满足AsyncStream，或这两种情况都有。</cn><br>
Any arguments supplied to the constructor of the stream wrapper are forwarded to next layer&rsquo;s constructor.<br>
<cn>提供给流包装器的构造函数的所有参数都将转发到下一层的构造函数。</cn></p>

<p>The value of deflateSupported determines if the stream will support (but not require) the permessage-deflate extension (rfc7692) negotiation during handshaking. <br>
<cn>deflateSupported的值确定是否将支持（但不要求）流在握手协商期间的permessage-deflate扩展（rfc7692）。</cn><br>
This extension allows messages to be optionally automatically compressed using the deflate algorithm prior to transmission. <br>
<cn>此扩展允许在传输之前使用deflate算法自动压缩消息。</cn>
When this boolean value is false, the extension is disabled. <br>
<cn>当此布尔值是false时，扩展被禁用。</cn><br>
Applications which do not intend to use the permessage-deflate extension may set the value to false to enjoy a reduction in the size of the compiled output, as the necessary compression code (included with Beast) will not be compiled in.<br>
<cn>不打算使用permessage-deflate扩展的应用程序可以将其值设置为false,以减小已编译输出的大小，因为不会编译所需的压缩代码（包含在Beast中)</cn></p>

<p>Here we declare a websocket stream over a TCP/IP socket with ownership of the socket.<br>
<cn>在这里，我们通过具有套接字所有权的TCP / IP套接字声明了一个websocket流。</cn><br>
The io_context argument is forwarded to the wrapped socket&rsquo;s constructor:<br>
<cn>该io_context参数将转发给包装的套接字的构造函数：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">stream<span style="color:#f92672">&lt;</span>boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ip<span style="color:#f92672">::</span>tcp<span style="color:#f92672">::</span>socket<span style="color:#f92672">&gt;</span> ws{ioc};
</code></pre></div>
<h3 id="using-ssl-cn-使用ssl-cn">Using SSL <cn>使用SSL</cn></h3>

<p>To use WebSockets over SSL, use an instance of the boost::asio::ssl::stream class template as the template type for the stream. <br>
<cn>要通过SSL使用WebSocket，请使用 boost::asio::ssl::stream类模板的实例作为流的模板类型。</cn><br>
The required boost::asio::io_context and boost::asio::ssl::context arguments are forwarded to the wrapped stream&rsquo;s constructor:<br>
<cn>所需的boost::asio::io_context和boost::asio::ssl::context参数转发到包装的流的构造函数：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/beast/websocket/ssl.hpp&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/asio/ssl.hpp&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ssl<span style="color:#f92672">::</span>context ctx{boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ssl<span style="color:#f92672">::</span>context<span style="color:#f92672">::</span>sslv23};
stream<span style="color:#f92672">&lt;</span>boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ssl<span style="color:#f92672">::</span>stream<span style="color:#f92672">&lt;</span>boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ip<span style="color:#f92672">::</span>tcp<span style="color:#f92672">::</span>socket<span style="color:#f92672">&gt;&gt;</span> wss{ioc, ctx};
</code></pre></div>
<blockquote>
<p>Important<br>
Code which declares websocket stream objects using Asio SSL types must include the file<br>
<cn>使用Asio SSL类型声明websocket流对象的代码必须包含该文件</cn></p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#f92672">&lt;</span>boost<span style="color:#f92672">/</span>beast<span style="color:#f92672">/</span>websocket<span style="color:#f92672">/</span>ssl.hpp<span style="color:#f92672">&gt;</span>.
</code></pre></div>
<h3 id="non-owning-references-cn-非所有者参考-cn">Non-owning References <cn>非所有者参考</cn></h3>

<p>If a socket type supports move construction, a websocket stream may be constructed around the already existing socket by invoking the move constructor signature:<br>
<cn>如果套接字类型支持move构造，则可以通过调用move构造函数来包围已存在的套接字来构造websocket流：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">stream<span style="color:#f92672">&lt;</span>boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ip<span style="color:#f92672">::</span>tcp<span style="color:#f92672">::</span>socket<span style="color:#f92672">&gt;</span> ws{std<span style="color:#f92672">::</span>move(sock)};
</code></pre></div>
<p>Or, the wrapper can be constructed with a non-owning reference. In this case, the caller is responsible for managing the lifetime of the underlying socket being wrapped:<br>
<cn>或者，可以使用非所有者引用构造包装器。在这种情况下，调用方负责管理要包装的基础套接字的生存期：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">stream<span style="color:#f92672">&lt;</span>boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ip<span style="color:#f92672">::</span>tcp<span style="color:#f92672">::</span>socket<span style="color:#f92672">&amp;&gt;</span> ws{sock};
</code></pre></div>
<p>Once the WebSocket stream wrapper is created, the wrapped object may be accessed by calling stream::next_layer:<br>
<cn>创建WebSocket流包装器后，可以通过调用以下方法访问包装的对象： stream::next_layer<cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">ws.next_layer().shutdown(boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ip<span style="color:#f92672">::</span>tcp<span style="color:#f92672">::</span>socket<span style="color:#f92672">::</span>shutdown_send);
</code></pre></div>
<blockquote>
<p>Warning<br>
Initiating operations on the next layer while websocket operations are being performed may result in undefined behavior.<br>
<cn>在执行WebSocket操作时在下一层启动初始化可能会导致未定义的行为。</cn></p>
</blockquote>

<h3 id="non-blocking-mode-cn-非阻塞模式-cn">Non-Blocking Mode <cn>非阻塞模式</cn></h3>

<p>Please note that websocket streams do not support non-blocking modes.<br>
<cn>请注意，websocket流不支持非阻塞模式。</cn></p>

<h2 id="establishing-connections-cn-建立连接-cn">Establishing Connections <cn>建立连接</cn></h2>

<p>Connections are established by invoking functions directly on the next layer object. <br>
<cn>通过直接在下一层对象上调用函数来建立连接。</cn><br>
For example, to make an outgoing connection using a standard TCP/IP socket:<br>
<cn>例如，要使用标准TCP / IP套接字建立传出连接：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> host <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;example.com&#34;</span>;
boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ip<span style="color:#f92672">::</span>tcp<span style="color:#f92672">::</span>resolver r{ioc};
stream<span style="color:#f92672">&lt;</span>boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ip<span style="color:#f92672">::</span>tcp<span style="color:#f92672">::</span>socket<span style="color:#f92672">&gt;</span> ws{ioc};
<span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">const</span> results <span style="color:#f92672">=</span> r.resolve(host, <span style="color:#e6db74">&#34;ws&#34;</span>);
boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>connect(ws.next_layer(), results.begin(), results.end());
</code></pre></div>
<p>Similarly, to accept an incoming connection using a standard TCP/IP socket, pass the next layer object to the acceptor:<br>
<cn>同样，要使用标准TCP / IP套接字接受传入连接，请将下一层对象传递给接受器：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ip<span style="color:#f92672">::</span>tcp<span style="color:#f92672">::</span>acceptor acceptor{ioc};
stream<span style="color:#f92672">&lt;</span>boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ip<span style="color:#f92672">::</span>tcp<span style="color:#f92672">::</span>socket<span style="color:#f92672">&gt;</span> ws{acceptor.get_executor().context()};
acceptor.accept(ws.next_layer());
</code></pre></div>
<p>When using SSL, which itself wraps a next layer object that is usually a TCP/IP socket, multiple calls to retrieve the next layer may be required. <br>
<cn>使用SSL（本身包装通常是TCP / IP套接字的下一层对象）时，可能需要多次调用来检索下一层。</cn><br>
In this example, the websocket stream wraps the SSL stream which wraps the TCP/IP socket:<br>
<cn>在此示例中，websocket流包装了SSL流，其中SSL包装了TCP / IP套接字：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ip<span style="color:#f92672">::</span>tcp<span style="color:#f92672">::</span>endpoint ep;
boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ssl<span style="color:#f92672">::</span>context ctx{boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ssl<span style="color:#f92672">::</span>context<span style="color:#f92672">::</span>sslv23};
stream<span style="color:#f92672">&lt;</span>boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ssl<span style="color:#f92672">::</span>stream<span style="color:#f92672">&lt;</span>boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ip<span style="color:#f92672">::</span>tcp<span style="color:#f92672">::</span>socket<span style="color:#f92672">&gt;&gt;</span> ws{ioc, ctx};

<span style="color:#75715e">// connect the underlying TCP/IP socket
</span><span style="color:#75715e"></span>ws.next_layer().next_layer().connect(ep);

<span style="color:#75715e">// perform SSL handshake
</span><span style="color:#75715e"></span>ws.next_layer().handshake(boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ssl<span style="color:#f92672">::</span>stream_base<span style="color:#f92672">::</span>client);

<span style="color:#75715e">// perform WebSocket handshake
</span><span style="color:#75715e"></span>ws.handshake(<span style="color:#e6db74">&#34;localhost&#34;</span>, <span style="color:#e6db74">&#34;/&#34;</span>);
</code></pre></div>
<blockquote>
<p>Note<br>
Examples use synchronous interfaces for clarity of exposition; signatures for asynchronous operations are also provided.<br>
<cn>示例使用了同步接口以使说明更清晰；还提供了用于异步操作的签名。</cn></p>
</blockquote>

<h2 id="handshaking-clients-cn-握手-客户端-cn">Handshaking (Clients) <cn>握手（客户端）</cn></h2>

<p>A WebSocket session begins when a client sends the HTTP/1 Upgrade request for websocket, and the server sends an appropriate response indicating that the request was accepted and that the connection has been upgraded. <br>
<cn>当客户端发送对websocket的HTTP/1 升级请求时，WebSocket会话开始，服务器发送适当的响应，指示该请求已被接受并且连接已升级。</cn><br>
The Upgrade request must include the Host field, and the target of the resource to request. <br>
<cn>升级请求必须包含主机字段和要请求的资源目标。</cn><br>
The stream member functions handshake and async_handshake are used to send the request with the required host and target strings.<br>
<cn>流成员函数handshake和async_handshake用于发送与所需主机和目标串的请求。</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">ws.handshake(<span style="color:#e6db74">&#34;localhost&#34;</span>, <span style="color:#e6db74">&#34;/&#34;</span>);
</code></pre></div>
<p>The implementation will create and send a request that typically looks like this:<br>
<cn>该实现将创建并发送通常如下所示的请求：</cn></p>

<p>Table 1.24. WebSocket Upgrade HTTP Request<br>
<cn>表1.24。WebSocket升级HTTP请求</cn></p>

<table>
<thead>
<tr>
<th align="left">Serialized Octets</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">GET / HTTP/1.1<br>Host: localhost<br>Upgrade: websocket<br>Connection: upgrade<br>Sec-WebSocket-Key: 2pGeTR0DsE4dfZs2pH+8MA==<br> Sec-WebSocket-Version: 13<br> User-Agent: Beast<br></td>
<td align="left">The host and target parameters become part of the Host field and request-target in the resulting HTTP request.<br><cn>host和target参数成为结果HTTP请求中Host字段和request-target的一部分。</cn><br>The key is generated by the implementation. Callers may add fields or modify fields by providing a decorator, described below.<br><cn>密钥由实现生成。调用者可以通过提供装饰器来添加字段或修改字段，如下所述。</cn></td>
</tr>
</tbody>
</table>

<h3 id="decorators-cn-装饰器-cn">Decorators <cn>装饰器</cn></h3>

<p>If the caller wishes to add or modify fields, the member functions handshake_ex and async_handshake_ex are provided which allow an additional function object, called a decorator, to be passed. <br>
<cn>如果调用者希望添加或修改字段，可以使用成员函数handshake_ex和async_handshake_ex，它们允许传递一个称之为修饰器的附加函数对象。</cn><br>
The decorator is invoked to modify the HTTP Upgrade request as needed. <br>
<cn>根据需要调用装饰器以修改HTTP升级请求。</cn><br>
This example sets a subprotocol on the request:<br>
<cn>本示例对请求设置一个子协议：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">ws.handshake_ex(<span style="color:#e6db74">&#34;localhost&#34;</span>, <span style="color:#e6db74">&#34;/&#34;</span>,
    [](request_type<span style="color:#f92672">&amp;</span> m)
    {
        m.insert(http<span style="color:#f92672">::</span>field<span style="color:#f92672">::</span>sec_websocket_protocol, <span style="color:#e6db74">&#34;xmpp;ws-chat&#34;</span>);
    });
</code></pre></div>
<p>The HTTP Upgrade request produced by the previous call will look thusly:<br>
<cn>因此，上一个调用产生的HTTP升级请求将如下所示：</cn></p>

<blockquote>
<p>Table 1.25. Decorated WebSocket Upgrade HTTP Request<br>
<cn>表1.25。装饰的WebSocket升级HTTP请求</cn></p>
</blockquote>

<table>
<thead>
<tr>
<th align="left">Serialized Octets</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">GET / HTTP/1.1<br>Host: localhost<br> Upgrade: websocket<br> Connection: upgrade<br> Sec-WebSocket-Key: 2pGeTR0DsE4dfZs2pH+8MA==<br> Sec-WebSocket-Version: 13<br> Sec-WebSocket-Protocol: xmpp;ws-chat<br> User-Agent: Beast</td>
<td align="left">Undefined behavior results if the decorator modifies the fields specific to perform the WebSocket Upgrade , such as the Upgrade and Connection fields.<br><cn>如果装饰器修改特定于执行WebSocket升级的字段（例如，Upgrade和Connection字段），则会导致未定义的行为。</cn><br></td>
</tr>
</tbody>
</table>

<h3 id="filtering-cn-筛选-cn">Filtering <cn>筛选</cn></h3>

<p>When a client receives an HTTP Upgrade response from the server indicating a successful upgrade, the caller may wish to perform additional validation on the received HTTP response message. <br>
<cn>当客户端从服务器接收到指示成功升级的HTTP升级响应时，调用者可能希望对收到的HTTP响应消息执行其他验证。</cn><br>
For example, to check that the response to a basic authentication challenge is valid. <br>
<cn>例如，检查对基本身份验证质询的响应是否有效。</cn><br>
To achieve this, overloads of the handshake member function allow the caller to store the received HTTP message in an output reference argument of type response_type as follows:<br>
<cn>为了实现这一点，握手成员函数的重载允许调用者将接收到的HTTP消息存储在response_type类型的输出引用参数中,如下所示：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">response_type res;
ws.handshake(res, <span style="color:#e6db74">&#34;localhost&#34;</span>, <span style="color:#e6db74">&#34;/&#34;</span>);
<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span> res.count(http<span style="color:#f92672">::</span>field<span style="color:#f92672">::</span>sec_websocket_protocol))
    <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>invalid_argument(<span style="color:#e6db74">&#34;missing subprotocols&#34;</span>);
</code></pre></div>
<h2 id="handshaking-servers-cn-握手-服务端-cn">Handshaking (Servers) <cn>握手(服务端)</cn></h2>

<p>A stream automatically handles receiving and processing the HTTP response to the handshake request. <br>
<cn>stream自动处理对握手请求的HTTP响应的接收和处理。</cn><br>
The call to handshake is successful if a HTTP response is received with the 101 Switching Protocols status code. <br>
<cn>如果收到带有101交换协议状态代码的HTTP响应，则握手调用成功。</cn><br>
On failure, an error is returned or an exception is thrown. <br>
<cn>失败时，将返回错误或引发异常。</cn><br>
Depending on the keep alive setting, the connection may remain open for a subsequent handshake attempt.<br>
<cn>根据保持活动设置，连接可能会保持打开状态，以进行后续的握手尝试。</cn></p>

<p>Performing a handshake for an incoming websocket upgrade request operates similarly. <br>
<cn>对传入的Websocket升级请求执行握手的操作类似。</cn><br>
If the handshake fails, an error is returned or exception thrown:<br>
<cn>如果握手失败，将返回错误或引发异常：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">ws.accept();
</code></pre></div>
<p>Successful WebSocket Upgrade responses generated by the implementation will typically look like this:<br>
<cn>由实现生成的成功的WebSocket升级响应通常如下所示：</cn></p>

<p>Table 1.26. Decorated WebSocket Upgrade HTTP Request<br>
<cn>表1.26。被装饰的WebSocket升级HTTP请求</cn></p>

<table>
<thead>
<tr>
<th align="left">Serialized Octets</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">HTTP/1.1 101 Switching Protocols<br> Upgrade: websocket<br> Connection: upgrade<br> Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=<br> Server: Beast/40</td>
<td align="left">The Sec-WebSocket-Accept field value is generated from the request in a fashion specified by the WebSocket protocol.<br><cn>Sec-WebSocket-Accept字段值是由请求以WebSocket协议指定的方式生成。</cn></td>
</tr>
</tbody>
</table>

<h3 id="decorators-cn-装饰器-cn-1">Decorators <cn>装饰器</cn></h3>

<p>If the caller wishes to add or modify fields, the member functions accept_ex and async_accept_ex are provided which allow an additional function object, called a decorator, to be passed. <br>
<cn>如果调用者希望添加或修改字段，可以使用成员函数handshake_ex和async_handshake_ex，它们允许传递一个称之为修饰器的附加函数对象。</cn><br>
The decorator is invoked to modify the HTTP Upgrade request as needed. <br>
<cn>根据需要调用装饰器以修改HTTP升级请求。</cn><br>
This example sets the Server field on the response:<br>
<cn>这个例子在响应上设置Server字段：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">ws.accept_ex(
    [](response_type<span style="color:#f92672">&amp;</span> m)
    {
        m.insert(http<span style="color:#f92672">::</span>field<span style="color:#f92672">::</span>server, <span style="color:#e6db74">&#34;MyServer&#34;</span>);
    });
</code></pre></div>
<p>The HTTP Upgrade response produced by the previous call looks like this:<br>
<cn>上面调用产生的HTTP Upgrade响应如下所示</cn></p>

<blockquote>
<p>Table 1.27. Decorated WebSocket Upgrade HTTP Request<br>
<cn>表1.27。装饰的WebSocket升级HTTP请求</cn></p>
</blockquote>

<table>
<thead>
<tr>
<th align="left">Serialized Octets</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">HTTP/1.1 101 Switching Protocols<br> Upgrade: websocket<br> Connection: upgrade<br> Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=<br> Server: AcmeServer</td>
<td align="left">When the Upgrade request fails, the implementation will still invoke the decorator to modify the response. In this case, the response object will have a status code other than 101.<br><cn>当升级请求失败时，实现仍将调用装饰器来修改响应。在这种情况下，响应对象的状态码将不是101。</cn><br> Undefined behavior results when the upgrade request is successful and the decorator modifies the fields specific to perform the WebSocket Upgrade, such as the Upgrade and Connection fields.<br><cn>当升级请求成功时装饰器修改执行WebSocket升级的特定字段（例如Upgrade和Connection字段），将导致未定义的行为。</cn></td>
</tr>
</tbody>
</table>

<h3 id="passing-http-requests-cn-传递http请求-cn">Passing HTTP Requests <cn>传递HTTP请求</cn></h3>

<p>When implementing an HTTP server that also supports WebSocket, the server usually reads the HTTP request from the client. <br>
<cn>在实现额外支持WebSocket的HTTP服务器时，该服务器通常会从客户端读取HTTP请求。</cn><br>
To detect when the incoming HTTP request is a WebSocket Upgrade request, the function is_upgrade may be used.<br>
<cn>is_upgrade函数可以用来检测传入的HTTP请求何时为WebSocket升级请求。</cn></p>

<p>Once the caller determines that the HTTP request is a WebSocket Upgrade, additional overloads of accept, accept_ex, async_accept, and async_accept_ex are provided which receive the entire HTTP request header as an object to perform the handshake. <br>
<cn>一旦调用方确定该HTTP请求是WebSocket的升级，额外提供accept，accept_ex，async_accept和async_accept_ex的重载，这些重载将整个HTTP请求标头作为对象执行握手。</cn><br>
In this example, the request is first read in using the HTTP algorithms, and then passed to a newly constructed stream:<br>
<cn>在此示例中，首先使用HTTP算法读取请求，然后将其传递给新构建的流：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// Buffer required for reading HTTP messages
</span><span style="color:#75715e"></span>flat_buffer buffer;

<span style="color:#75715e">// Read the HTTP request ourselves
</span><span style="color:#75715e"></span>http<span style="color:#f92672">::</span>request<span style="color:#f92672">&lt;</span>http<span style="color:#f92672">::</span>string_body<span style="color:#f92672">&gt;</span> req;
http<span style="color:#f92672">::</span>read(sock, buffer, req);

<span style="color:#75715e">// See if its a WebSocket upgrade request
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span>(websocket<span style="color:#f92672">::</span>is_upgrade(req))
{
    <span style="color:#75715e">// Construct the stream, transferring ownership of the socket
</span><span style="color:#75715e"></span>    stream<span style="color:#f92672">&lt;</span>boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ip<span style="color:#f92672">::</span>tcp<span style="color:#f92672">::</span>socket<span style="color:#f92672">&gt;</span> ws{std<span style="color:#f92672">::</span>move(sock)};

    <span style="color:#75715e">// Clients SHOULD NOT begin sending WebSocket
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// frames until the server has provided a response.
</span><span style="color:#75715e"></span>    BOOST_ASSERT(buffer.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);

    <span style="color:#75715e">// Accept the upgrade request
</span><span style="color:#75715e"></span>    ws.accept(req);
}
<span style="color:#66d9ef">else</span>
{
    <span style="color:#75715e">// Its not a WebSocket upgrade, so
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// handle it like a normal HTTP request.
</span><span style="color:#75715e"></span>}
</code></pre></div>
<h3 id="buffered-handshakes-cn-带缓冲的握手-cn">Buffered Handshakes <cn>带缓冲的握手</cn></h3>

<p>Sometimes a server implementation wishes to read octets on the stream in order to route the incoming request. <br>
<cn>有时，服务器实现希望读取流中的字节，以路由传入的请求。</cn><br>
For example, a server may read the first 6 octets after accepting an incoming connection to determine if a TLS protocol is being negotiated, and choose a suitable implementation at run-time. <br>
<cn>例如，服务器可以在接受传入连接后读取前6个字节，以确定是否正在协商TLS协议，并在运行时选择合适的实现。</cn><br>
In the case where the server wishes to accept the incoming request as an HTTP WebSocket Upgrade request, additional overloads of accept, accept_ex, async_accept, and async_accept_ex are provided which receive the additional buffered octets and consume them as part of the handshake.<br>
<cn>在服务器希望将传入请求作为HTTP WebSocket升级请求接受的情况下，提供了accept，accept_ex，async_accept和async_accept_ex的额外重载，这些重载接收了额外的缓冲字节并将它们作为握手的一部分使用。</cn></p>

<p>In this example, the server reads the initial HTTP message into the specified dynamic buffer as an octet sequence in the buffer&rsquo;s output area, and later uses those octets to attempt an HTTP WebSocket Upgrade:<br>
<cn>在此示例中，服务器将初始HTTP消息作为缓冲区输出区域中的字节序列读入指定的动态缓冲区，然后再使用这些字节尝试进行HTTP WebSocket升级：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// Read into our buffer until we reach the end of the HTTP request.
</span><span style="color:#75715e">// No parsing takes place here, we are just accumulating data.
</span><span style="color:#75715e"></span>boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>streambuf buffer;
boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>read_until(sock, buffer, <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n\r\n</span><span style="color:#e6db74">&#34;</span>);

<span style="color:#75715e">// Now accept the connection, using the buffered data.
</span><span style="color:#75715e"></span>ws.accept(buffer.data());
</code></pre></div>
<p>The implementation uses a fixed-size storage area to hold buffers passed using these functions. <br>
<cn>该实现使用固定大小的存储区来保存使用这些函数传递的缓冲区。</cn><br>
If an application is reaching the limit of the internal buffer size, then the websocket stream may be instantiated with the next layer type of buffered_read_stream to wrap the underlying stream. <br>
<cn>如果应用程序已达到内部缓冲区大小的限制，则可以使用netxt layer的buffered_read_stream来实例化websocket流,以包装基础流。</cn><br>
The buffered handshake data may be first placed into the buffered read stream, which uses a dynamically sized buffer.<br>
<cn>可以先将缓冲的握手数据放入使用动态大小的缓冲区的缓冲读取流中</cn></p>

<h2 id="send-and-receive-messages-cn-发送和接收消息-cn">Send and Receive Messages <cn>发送和接收消息</cn></h2>

<p>Interfaces for transacting messages are structured into layers. <br>
<cn>用于处理消息的接口被构造为多个层。</cn><br>
The highest layer provides ease of use, while lower layers provide additional control and flexibility. <br>
<cn>最高层提供了易用性，而较低层则提供了额外的控制和灵活性。</cn><br>
The layers are arranged thusly:<br>
<cn>各个层是这样排列的：</cn></p>

<table>
<thead>
<tr>
<th align="left">Level</th>
<th align="left">Read/Write What</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">2</td>
<td align="left">message</td>
<td align="left">At the top layer, these functions allow for an entire message to be sent or received. <br><cn>在顶层，这些功能允许发送或接收整个消息。</cn><br> They are designed for ease of use: read, write, async_read, and async_write.<br><cn>它们是专为易用性设计的：read，write，async_read，和async_write。</cn></td>
</tr>

<tr>
<td align="left">1</td>
<td align="left">partial</td>
<td align="left">These read functions enable partial message data to be received into a DynamicBuffer. <br><cn>这些读取功能使部分消息数据可以接收到DynamicBuffer中。</cn><br>They can be configured to perform bounded work: read_some, and async_read_some.<br><cn>可以将它们配置为执行有限的工作：read_some和async_read_some。</cn></td>
</tr>

<tr>
<td align="left">0</td>
<td align="left">partial</td>
<td align="left">At the lowest level these read and write functions enable partial message data to be transacted using a constant or mutable buffer sequence: read_some, write_some, async_read_some, and async_write_some.<br><cn>在最低水平这些读写功能启用部分消息数据，使用恒定的或可变的缓冲序列进行事务处理：read_some，write_some，async_read_some，和 async_write_some。</cn></td>
</tr>
</tbody>
</table>

<p>After the WebSocket handshake is accomplished, callers may send and receive messages using the message oriented interface.<br>
<cn>完成WebSocket握手后，调用方可以使用面向消息的接口发送和接收消息。</cn><br>
This interface requires that all of the buffers representing the message are known ahead of time:<br>
<cn>此接口要求提前知道代表消息的所有缓冲区</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// This DynamicBuffer will hold the received message
</span><span style="color:#75715e">//此DynamicBuffer将保存收到的消息
</span><span style="color:#75715e"></span>multi_buffer buffer;

<span style="color:#75715e">// Read a complete message into the buffer&#39;s input area
</span><span style="color:#75715e">//将完整的消息读入缓冲区的输入区域
</span><span style="color:#75715e"></span>ws.read(buffer);

<span style="color:#75715e">// Set text mode if the received message was also text,
</span><span style="color:#75715e">// otherwise binary mode will be set.
</span><span style="color:#75715e">//如果收到的消息也是文本，则设置为文本模式，否则将设置为二进制模式。
</span><span style="color:#75715e"></span>ws.text(ws.got_text());

<span style="color:#75715e">// Echo the received message back to the peer. If the received
</span><span style="color:#75715e">// message was in text mode, the echoed message will also be
</span><span style="color:#75715e">// in text mode, otherwise it will be in binary mode.
</span><span style="color:#75715e">//将收到的消息回送给对等方。如果收到的消息处于文本模式，则回显的消息也将 处于文本模式，否则将处于二进制模式。
</span><span style="color:#75715e"></span>ws.write(buffer.data());

<span style="color:#75715e">// Discard all of the bytes stored in the dynamic buffer,
</span><span style="color:#75715e">// otherwise the next call to read will append to the existing
</span><span style="color:#75715e">// data instead of building a fresh message.
</span><span style="color:#75715e">//丢弃存储在动态缓冲区中的所有字节，否则，下一个要读取的调用将追加到现有数据中而不是生成新消息。
</span><span style="color:#75715e"></span>buffer.consume(buffer.size());
</code></pre></div>
<blockquote>
<p>Important<br>
websocket::stream is not thread-safe. Calls to stream member functions must all be made from the same implicit or explicit strand.<br>
<cn>websocket::stream不是线程安全的。对流成员函数的调用必须全部来自同一隐式或显式链。</cn></p>
</blockquote>

<h3 id="frames-cn-帧-cn">Frames <cn>帧</cn></h3>

<p>Some use-cases make it impractical or impossible to buffer the entire message ahead of time:<br>
<cn>一些用例使提前缓冲整个消息变得不切实际或不可能：</cn></p>

<ul>
<li>Streaming multimedia to an endpoint.<br><cn>将多媒体流传输到端点。</cn></li>
<li>Sending a message that does not fit in memory at once.<br><cn>一次发送一条超过内存的消息。</cn></li>
<li>Providing incremental results as they become available.<br><cn>提供可用的增量结果。</cn></li>
</ul>

<p>For these cases, the partial data oriented interface may be used. <br>
<cn>对于这些情况，可以使用面向部分数据的接口。</cn><br>
This example reads and echoes a complete message using this interface:<br>
<cn>本示例使用以下接口读取并回显完整的消息：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// This DynamicBuffer will hold the received message
</span><span style="color:#75715e">//此DynamicBuffer将保存收到的消息
</span><span style="color:#75715e"></span>multi_buffer buffer;

<span style="color:#75715e">// Read the next message in pieces
</span><span style="color:#75715e">//分段读取下一条消息
</span><span style="color:#75715e"></span><span style="color:#66d9ef">do</span>
{
    <span style="color:#75715e">// Append up to 512 bytes of the message into the buffer
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//将最多512字节的消息附加到缓冲区
</span><span style="color:#75715e"></span>    ws.read_some(buffer, <span style="color:#ae81ff">512</span>);
}
<span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span> ws.is_message_done());

<span style="color:#75715e">// At this point we have a complete message in the buffer, now echo it
</span><span style="color:#75715e">//此时，我们在缓冲区中有一条完整的消息，现在回显它
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// The echoed message will be sent in binary mode if the received
</span><span style="color:#75715e">// message was in binary mode, otherwise we will send in text mode.
</span><span style="color:#75715e">//如果收到的消息是二进制模式，则回显的消息将以二进制模式发送，否则，将以文本模式发送。
</span><span style="color:#75715e"></span>ws.binary(ws.got_binary());

<span style="color:#75715e">// This buffer adapter allows us to iterate through buffer in pieces
</span><span style="color:#75715e">//此缓冲区适配器使我们可以逐段迭代缓冲区
</span><span style="color:#75715e"></span>buffers_suffix<span style="color:#f92672">&lt;</span>multi_buffer<span style="color:#f92672">::</span>const_buffers_type<span style="color:#f92672">&gt;</span> cb{buffer.data()};

<span style="color:#75715e">// Echo the received message in pieces.
</span><span style="color:#75715e">//逐段回显收到的消息。
</span><span style="color:#75715e">// This will cause the message to be broken up into multiple frames.
</span><span style="color:#75715e">//这将导致消息分解为多个帧。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>(;;)
{
    <span style="color:#66d9ef">using</span> boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>buffer_size;
    <span style="color:#66d9ef">if</span>(buffer_size(cb) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">512</span>)
    {
        <span style="color:#75715e">// There are more than 512 bytes left to send, just
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// send the next 512 bytes. The value `false` informs
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// the stream that the message is not complete.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//超过512字节要发送，仅发送下一个512字节。值“ false”通知流消息未完成。
</span><span style="color:#75715e"></span>        ws.write_some(false, buffers_prefix(<span style="color:#ae81ff">512</span>, cb));

        <span style="color:#75715e">// This efficiently discards data from the adapter by
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// simply ignoring it, but does not actually affect the
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// underlying dynamic buffer.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//通过简单地忽略它，可以有效地从适配器中丢弃数据，但实际上不会影响基础动态缓冲区。
</span><span style="color:#75715e"></span>        cb.consume(<span style="color:#ae81ff">512</span>);
    }
    <span style="color:#66d9ef">else</span>
    {
        <span style="color:#75715e">// Only 512 bytes or less remain, so write the whole
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// thing and inform the stream that this piece represents
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// the end of the message by passing `true`.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//仅剩下512个字节或更少，因此写入整个内容，并通过传递true来通知流此段代表消息的末尾。
</span><span style="color:#75715e"></span>        ws.write_some(true, cb);
        <span style="color:#66d9ef">break</span>;
    }
}

<span style="color:#75715e">// Discard all of the bytes stored in the dynamic buffer,
</span><span style="color:#75715e">// otherwise the next call to read will append to the existing
</span><span style="color:#75715e">// data instead of building a fresh message.
</span><span style="color:#75715e">//丢弃存储在动态缓冲区中的所有字节，否则下一个要读取的调用将追加到现有数据上，而不是生成新消息。
</span></code></pre></div>
<h2 id="control-frames-cn-控制帧-cn">Control Frames <cn>控制帧</cn></h2>

<p>Control frames are small (less than 128 bytes) messages entirely contained in an individual WebSocket frame. <br>
<cn>控制帧是完全包含在单个WebSocket帧中的小消息（少于128个字节）。</cn><br>
They may be sent at any time by either peer on an established connection, and can appear in between continuation frames for a message. <br>
<cn>它们可以随时由任何对等方在已建立的连接上发送，并且可以出现在消息的连续帧之间。</cn><br>
There are three types of control frames: ping, pong, and close.<br>
<cn>控制帧有三种类型：ping，pong和close。</cn></p>

<p>A sent ping indicates a request that the sender wants to receive a pong. <br>
<cn>发送的ping表示发送者想要接收一个Pong的请求。</cn><br>
A pong is a response to a ping. <br>
<cn>pong是ping的响应。</cn><br>
Pongs may be sent unsolicited, at any time. <br>
<cn>pong可以随时主动发送。</cn><br>
One use for an unsolicited pong is to inform the remote peer that the session is still active after a long period of inactivity. <br>
<cn>不请自来的Pong的一种用法是通知远程对等方，在长时间不活动之后，该会话仍处于活动状态。</cn><br>
A close frame indicates that the remote peer wishes to close the WebSocket connection. <br>
<cn>close帧表示远程对等方希望关闭WebSocket连接。</cn><br>
The connection is considered gracefully closed when each side has sent and received a close frame.<br>
<cn>当双方发送和接收到close帧时，该连接被视为正常关闭。</cn></p>

<p>During read operations, Beast automatically reads and processes control frames. <br>
<cn>在读取操作过程中，Beast自动读取并处理控制帧。</cn><br>
If a control callback is registered, the callback is notified of the incoming control frame. <br>
<cn>如果控制回调已注册，则将传入的控制帧通知给回调。</cn><br>
The implementation will respond to pings automatically. <br>
<cn>该实现将自动响应ping。</cn><br>
The receipt of a close frame initiates the WebSocket close procedure, eventually resulting in the error code error::closed being delivered to the caller in a subsequent read operation, assuming no other error takes place.<br>
<cn>假设没有其他错误发生，close帧的接收将启动WebSocket关闭过程，最终导致错误代码在后续的读取操作中传递给调用方。</cn></p>

<p>A consequence of this automatic behavior is that caller-initiated read operations can cause socket writes. <br>
<cn>这种自动行为的结果是，调用者启动的读取操作可能导致套接字写入。</cn><br>
However, these writes will not compete with caller-initiated write operations. <br>
<cn>但是，这些写入将无法与调用方发起的写入操作竞争。</cn><br>
For the purposes of correctness with respect to the stream invariants, caller-initiated read operations still only count as a read. <br>
<cn>为了关于流不变性的正确性，调用者发起的读取操作仍仅算作读取。</cn><br>
This means that callers can have a simultaneously active read, write, and ping/pong operation in progress, while the implementation also automatically handles control frames.<br>
<cn>这意味着呼叫者可以同时进行有效的读取，写入和ping / pong操作，同时实现还可以自动处理控制帧。</cn></p>

<h3 id="control-callback-cn-控制回调-cn">Control Callback <cn>控制回调</cn></h3>

<p>Ping, pong, and close messages are control frames which may be sent at any time by either peer on an established WebSocket connection. <br>
<cn>ping，pong和close消息是控制帧，可以由已建立的WebSocket连接上的任何对等方随时发送。</cn><br>
They are sent using the functions ping, pong. and close. <br>
<cn>他们使用ping，pong和close函数来发送。</cn><br>
To be notified of control frames, callers may register a control callback using control_callback. <br>
<cn>为了得到控制帧通知，调用者可以使用control_callback来注册控制回调。</cn><br>
The object provided with this option should be callable with the following signature:<br>
<cn>随此选项提供的对象要可通过以下签名调用：</cn><br></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ws.control_callback(
    [](frame_type kind, string_view payload)
    {
        <span style="color:#75715e">// Do something with the payload
</span><span style="color:#75715e"></span>        boost<span style="color:#f92672">::</span>ignore_unused(kind, payload);
    });
</code></pre></div>
<p>When a control callback is registered, it will be invoked for all pings, pongs, and close frames received through either synchronous read functions or asynchronous read functions. <br>
<cn>注册控制回调后，同步读取函数或异步读取函数接收到的ping，pong和close帧都会调用该回调。</cn><br>
The type of frame and payload text are passed as parameters to the control callback. <br>
<cn>帧和有效载荷文本的类型作为参数传递给控制回调。</cn><br>
If the frame is a close frame, the close reason may be obtained by calling reason.<br>
<cn>如果该帧是关闭帧，则可以通过调用获得关闭原因</cn></p>

<p>Unlike regular completion handlers used in calls to asynchronous initiation functions, the control callback only needs to be set once. <br>
<cn>与异步初始化函数的调用中使用的常规完成处理程序不同，控制回调仅需要设置一次。</cn><br>
The callback is not reset after being called. <br>
<cn>回调在被调用后不会重置。</cn><br>
The same callback is used for both synchronous and asynchronous reads. <br>
<cn>同步和异步读取都使用相同的回调。</cn><br>
The callback is passive; in order to be called, a stream read operation must be active.<br>
<cn>回调是被动的；为了被调用，流读取操作必须是活动的。</cn></p>

<blockquote>
<p>Note<br>
When an asynchronous read function receives a control frame, the control callback is invoked in the same manner as that used to invoke the final completion handler of the corresponding read function.<br>
<cn>当异步读取函数接收到控制帧时，将以与用于调用相应读取函数的最终completion handler相同的方式调用控制回调。</cn></p>
</blockquote>

<h3 id="close-frames-cn-关闭帧-cn">Close Frames <cn>关闭帧</cn></h3>

<p>The WebSocket protocol defines a procedure and control message for initiating a close of the session. <br>
<cn>WebSocket协议定义了开始关闭会话的过程和控制消息。</cn><br>
In this procedure, a host requests the close by sending a close frame. <br>
<cn>在此过程中，主机通过发送关闭帧来请求关闭。</cn><br>
To request a close use a close function such as close or async_close:<br>
<cn>要请求关闭，请使用关闭函数，例如 close或async_close：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ws.close(close_code<span style="color:#f92672">::</span>normal);
</code></pre></div>
<p>The close function will send a close frame, read and discard incoming message data until receiving a close frame, and then shut down the underlying connection before returning.<br>
<cn>关闭功能将发送关闭帧，读取并丢弃传入的消息数据，直到接收到关闭帧，然后在返回之前关闭基础连接。</cn></p>

<p>When a close frame is received by during a read operation, the implementation will automatically respond with a close frame and then shut down the underlying connection before returning. <br>
<cn>在读取操作期间接收到关闭帧时，实现将自动以关闭帧进行响应，然后在返回之前关闭基础连接。</cn><br>
In this case, the read operation will complete with the code error::closed. <br>
<cn>在这种情况下，读取操作将使用code完成。</cn><br>
This indicates to the caller that the connection has been closed cleanly.<br>
<cn>这向调用者表明连接已完全关闭。</cn></p>

<blockquote>
<p>Important<br>
To receive the error::closed error, a read operation is required.<br>
<cn>要接收该错误，需要进行读取操作。</cn></p>
</blockquote>

<h3 id="auto-fragment-cn-自动分段-cn">Auto-fragment <cn>自动分段</cn></h3>

<p>To ensure timely delivery of control frames, large outgoing messages can be broken up into smaller sized frames. <br>
<cn>为了确保及时传递控制帧，可以将较大的传出消息分解为较小的帧。</cn><br>
The automatic fragment option turns on this feature, and the write buffer size option determines the maximum size of the fragments:<br>
<cn>自动分段选项启用了此功能，而写缓冲区大小选项确定片段的最大大小：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ws.auto_fragment(true);
ws.write_buffer_size(<span style="color:#ae81ff">16384</span>);
</code></pre></div>
<h2 id="teardown-cn-拆解-cn">Teardown <cn>拆解</cn></h2>

<p>The WebSocket protocol requirements described in rfc6455 section 7.1.1 outline an operation described as Close the WebSocket Connection. <br>
<cn>rfc6455第7.1.1节中描述的WebSocket协议概述了称为“ 关闭WebSocket连接”的操作需求。</cn><br>
This operation cleanly discards bytes remaining at receiving endpoints and also closes the underlying TCP/IP connection. <br>
<cn>此操作会干净地丢弃接收端点处剩余的字节，并关闭基础的TCP / IP连接。</cn><br>
Orderly shutdowns are always preferred; for TLS or SSL streams, a protocol-level shutdown is desired. <br>
<cn>有序的关闭总是首选；对于TLS或SSL流，需要协议级别的关闭。</cn><br>
This presents a small issue for the stream implementation: the stream&rsquo;s NextLayer template type requires only SyncStream or AsyncStream, but those concepts do not support the operations to shut down the connection.<br>
<cn>这给stream 实现带来了一个小问题 ：stream的NextLayer模板类型仅需要SyncStream或AsyncStream，但是这些概念不支持关闭连接的操作。</cn></p>

<p>To enable the implementation to perform the shutdown components of the close operation, the library exposes two customization points expressed as free functions associated with the next layer type:<br>
<cn>为了使实现能够执行关闭操作的关闭组件，该库公开了两个定制点，这些定制点表示为与next layer类型关联的自由函数：</cn></p>

<ul>
<li>teardown: Overloads of this function drain and shut down a stream synchronously.<br> <cn>teardown: 此功能的重载会同时耗尽并关闭流。</cn></li>
<li>async_teardown: Overloads of this function drain and shut down a stream asynchronously.<br><cn>async_teardown：此函数的重载耗尽并异步关闭流。</cn></li>
</ul>

<p>The implementation provides suitable overloads of the teardown customization points when websocket streams are instantiated using the Asio types boost::asio::ip::tcp::socket or boost::asio::ssl::stream for the next layer. <br>
<cn>当使用Asio类型boost::asio::ip::tcp::socket 或 boost::asio::ssl::stream作为next layer来实例化Websocket streams时，该实现为拆解自定义点提供适当的重载。</cn><br>
In this case no user action is required. <br>
<cn>在这种情况下，无需用户采取任何措施。</cn><br>
However, when the websocket stream is instantiated for a user-defined type, compile errors will result if the customization points are not provided for the user defined type. <br>
<cn>但是，当为用户自定义的类型实例化websocket stream时，如果未为用户自定义的类型提供定制点，则将导致编译错误。</cn><br>
Furthermore, user-defined types that wrap one of the Asio objects mentioned earlier may wish to invoke a teardown customization point for the wrapped object. <br>
<cn>此外，包装前面提到的一个Asio对象之一的用户自定义类型可能希望为包装的对象调用拆卸自定义点。</cn><br>
This is how those tasks are accomplished.<br>
<cn>这就是完成这些任务的方式。</cn></p>

<h3 id="user-defined-teardown-cn-用户定义的拆解-cn">User-defined Teardown <cn>用户定义的拆解</cn></h3>

<p>To provide overloads of teardown for a user-defined type, simply declare the two free functions with the correct signature, accepting a reference to the user-defined type as the stream parameter:<br>
<cn>要提供用户定义类型的拆解重载，只需声明两个具有正确签名的自由函数，并接受对用户定义类型的引用作为流参数：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">custom_stream</span>;

<span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">teardown</span>(
    role_type role,
    custom_stream<span style="color:#f92672">&amp;</span> stream,
    error_code<span style="color:#f92672">&amp;</span> ec);

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TeardownHandler</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span>
async_teardown(
    role_type role,
    custom_stream<span style="color:#f92672">&amp;</span> stream,
    TeardownHandler<span style="color:#f92672">&amp;&amp;</span> handler);
</code></pre></div>
<p>When the implementation invokes the asynchronous teardown function, it always uses an invokable completion handler. <br>
<cn>当实现调用异步拆卸函数时，它始终使用可调用的完成处理程序。</cn><br>
It is not necessary to specify the return type customization when creating user-defined overloads of async_teardown.<br>
<cn>创建用户定义的重载时，无需指定返回类型定制</cn></p>

<h3 id="invoking-teardown-cn-调用拆解-cn">Invoking Teardown <cn>调用拆解</cn></h3>

<p>To invoke the customization point, first bring the default implementation into scope with a using statement. <br>
<cn>要调用定制点，请首先使用using语句将默认实现纳入范围。</cn><br>
Then call the customization point without namespace qualification, allowing <br>
<cn>然后在没有名称空间限定的情况下调用自定义点，从而使依赖于参数的查找生效：argument-dependent lookup to take effect:</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NextLayer</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">custom_wrapper</span>
{
    NextLayer next_layer;

    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">Args</span><span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">explicit</span>
    custom_wrapper(Args<span style="color:#f92672">&amp;&amp;</span>... args)
        <span style="color:#f92672">:</span> next_layer(std<span style="color:#f92672">::</span>forward<span style="color:#f92672">&lt;</span>Args<span style="color:#f92672">&gt;</span>(args)...)
    {
    }

    <span style="color:#66d9ef">friend</span>
    <span style="color:#66d9ef">void</span>
    <span style="color:#a6e22e">teardown</span>(
        role_type role,
        custom_wrapper<span style="color:#f92672">&amp;</span> stream,
        error_code<span style="color:#f92672">&amp;</span> ec)
    {
        <span style="color:#66d9ef">using</span> boost<span style="color:#f92672">::</span>beast<span style="color:#f92672">::</span>websocket<span style="color:#f92672">::</span>teardown;
        teardown(role, stream.next_layer, ec);
    }

    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TeardownHandler</span><span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">friend</span>
    <span style="color:#66d9ef">void</span>
    async_teardown(
        role_type role,
        custom_wrapper<span style="color:#f92672">&amp;</span> stream,
        TeardownHandler<span style="color:#f92672">&amp;&amp;</span> handler)
    {
        <span style="color:#66d9ef">using</span> boost<span style="color:#f92672">::</span>beast<span style="color:#f92672">::</span>websocket<span style="color:#f92672">::</span>async_teardown;
        async_teardown(role, stream.next_layer, std<span style="color:#f92672">::</span>forward<span style="color:#f92672">&lt;</span>TeardownHandler<span style="color:#f92672">&gt;</span>(handler));
    }
};
</code></pre></div>
<h2 id="notes-cn-提示-cn">Notes <cn>提示</cn></h2>

<p>Because calls to read data may return a variable amount of bytes, the interface to calls that read data require an object that meets the requirements of DynamicBuffer. <br>
<cn>由于读取数据的调用可能返回可变数量的字节，因此读取数据的调用接口需要一个满足DynamicBuffer要求的对象 。</cn><br>
This concept is modeled on boost::asio::streambuf.<br>
<cn>这个概念是基于boost::asio::streambuf</cn></p>

<p>The implementation does not perform queueing or buffering of messages. <br>
<cn>该实现不执行消息的排队或缓冲。</cn><br>
If desired, these features should be provided by callers. <br>
<cn>如果需要，这些功能应由呼叫者提供。</cn><br>
The impact of this design is that library users are in full control of the allocation strategy used to store data and the back-pressure applied on the read and write side of the underlying TCP/IP connection.<br>
<cn>这种设计的影响在于，库用户可以完全控制用于存储数据的分配策略以及应用于基础TCP / IP连接的读取和写入侧的back-pressure。</cn></p>

<h3 id="asynchronous-operations-cn-异步操作-cn">Asynchronous Operations <cn>异步操作</cn></h3>

<p>Asynchronous versions are available for all functions:<br>
<cn>异步版本可用于所有的函数：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">multi_buffer buffer;
ws.async_read(buffer,
    [](error_code, std<span style="color:#f92672">::</span>size_t)
    {
        <span style="color:#75715e">// Do something with the buffer
</span><span style="color:#75715e"></span>    });
</code></pre></div>
<p>Calls to asynchronous initiation functions support the extensible asynchronous model developed by the Boost.Asio author, allowing for traditional completion handlers, stackful or stackless coroutines, and even futures:<br>
<cn>对异步启动函数的调用支持Boost.Asio作者开发的可扩展异步模型，允许使用传统的完成处理程序，堆栈式或无堆栈式协程，甚至future：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">echo</span>(stream<span style="color:#f92672">&lt;</span>boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ip<span style="color:#f92672">::</span>tcp<span style="color:#f92672">::</span>socket<span style="color:#f92672">&gt;&amp;</span> ws,
    multi_buffer<span style="color:#f92672">&amp;</span> buffer, boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>yield_context yield)
{
    ws.async_read(buffer, yield);
    std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>size_t<span style="color:#f92672">&gt;</span> fut <span style="color:#f92672">=</span>
        ws.async_write(buffer.data(), boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>use_future);
}
</code></pre></div>
<p>The example programs that come with the library demonstrate the usage of websocket stream operations with all asynchronous varieties.<br>
<cn>该库随附的示例程序演示了所有异步类的websocket流操作的用法。</cn></p>

<h3 id="the-io-context">The io_context</h3>

<p>The creation and operation of the boost::asio::io_context associated with the underlying stream is left to the callers, permitting any implementation strategy including one that does not require threads for environments where threads are unavailable. <br>
<cn>boost::asio::io_context的建立和与底层流相关的操作留给调用者，允许任何执行策略，包括，在线程不可用的环境中的不需求线程。</cn><br>
Beast WebSocket itself does not use or require threads.<br>
<cn>Beast WebSocket本身不使用或不需要线程。</cn></p>

<h3 id="thread-safety-cn-线程安全-cn">Thread Safety <cn>线程安全</cn></h3>

<p>Like a regular Boost.Asio socket, a stream is not thread safe. <br>
<cn>像常规的Boost.Asio 套接字一样，stream也不是线程安全的。</cn><br>
Callers are responsible for synchronizing operations on the socket using an implicit or explicit strand, as per the Asio documentation. <br>
<cn>根据Asio文档，调用者负责使用隐式或显式链同步套接字上的操作。</cn><br>
The websocket stream asynchronous interface supports one of each of the following operations to be active at the same time:<br>
<cn>websocket stream 异步接口支持以下每个操作中的一个同时处于活动状态：</cn></p>

<ul>
<li>async_read or async_read_some</li>
<li>async_write or async_write_some</li>
<li>async_ping or async_pong</li>
<li>async_close</li>
</ul>

<p>For example, the following code is malformed, because the program is attempting to perform two simultaneous reads:<br>
<cn>例如，下面的代码格式错误，因为程序试图执行两个同时读取：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ws.async_read(b, [](error_code, std<span style="color:#f92672">::</span>size_t){});
ws.async_read(b, [](error_code, std<span style="color:#f92672">::</span>size_t){});
</code></pre></div>
<p>However, this code is well-formed:<br>
<cn>但是，此代码是良好的形成：</cn></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ws.async_read(b, [](error_code, std<span style="color:#f92672">::</span>size_t){});
ws.async_write(b.data(), [](error_code, std<span style="color:#f92672">::</span>size_t){});
ws.async_ping({}, [](error_code){});
ws.async_close({}, [](error_code){});
</code></pre></div>
<p>The implementation uses composed asynchronous operations; although some individiual operations can perform both reads and writes, this behavior is coordinated internally to make sure the underlying stream is operated in a safe fashion. <br>
<cn>该实现使用组合的异步操作；尽管某些个别操作可以执行读取和写入操作，但是此行为在内部得到了协调，以确保基础流以安全的方式进行操作。</cn><br>
This allows an asynchronous read operation to respond to a received ping frame even while a user-initiated call to asynchronous write is active.<br>
<cn>即使用户启动的异步写入调用处于活动状态，这也允许异步读取操作响应收到的ping帧。</cn></p><ul class="pa0">
  
   <li class="list">
     <a href="/tags/boost" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">boost</a>
   </li>
  
   <li class="list">
     <a href="/tags/beast" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">beast</a>
   </li>
  
   <li class="list">
     <a href="/tags/%E7%BF%BB%E8%AF%91" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">翻译</a>
   </li>
  
   <li class="list">
     <a href="/tags/websocket" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">websocket</a>
   </li>
  
   <li class="list">
     <a href="/tags/c&#43;&#43;" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">c&#43;&#43;</a>
   </li>
  
</ul>
<div class="mt6">
      
      <div id="commento"></div>
<script defer src="https://cdn.commento.io/js/commento.js"></script>

      </div>
    </section>

    <aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">What&#39;s in this post</p>
      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#using-websocket-cn-使用websocket-cn">Using WebSocket <cn>使用WebSocket</cn></a></li>
<li><a href="#creating-streams-cn-创建流-cn">Creating Streams <cn>创建流</cn></a>
<ul>
<li><a href="#using-ssl-cn-使用ssl-cn">Using SSL <cn>使用SSL</cn></a></li>
<li><a href="#non-owning-references-cn-非所有者参考-cn">Non-owning References <cn>非所有者参考</cn></a></li>
<li><a href="#non-blocking-mode-cn-非阻塞模式-cn">Non-Blocking Mode <cn>非阻塞模式</cn></a></li>
</ul></li>
<li><a href="#establishing-connections-cn-建立连接-cn">Establishing Connections <cn>建立连接</cn></a></li>
<li><a href="#handshaking-clients-cn-握手-客户端-cn">Handshaking (Clients) <cn>握手（客户端）</cn></a>
<ul>
<li><a href="#decorators-cn-装饰器-cn">Decorators <cn>装饰器</cn></a></li>
<li><a href="#filtering-cn-筛选-cn">Filtering <cn>筛选</cn></a></li>
</ul></li>
<li><a href="#handshaking-servers-cn-握手-服务端-cn">Handshaking (Servers) <cn>握手(服务端)</cn></a>
<ul>
<li><a href="#decorators-cn-装饰器-cn-1">Decorators <cn>装饰器</cn></a></li>
<li><a href="#passing-http-requests-cn-传递http请求-cn">Passing HTTP Requests <cn>传递HTTP请求</cn></a></li>
<li><a href="#buffered-handshakes-cn-带缓冲的握手-cn">Buffered Handshakes <cn>带缓冲的握手</cn></a></li>
</ul></li>
<li><a href="#send-and-receive-messages-cn-发送和接收消息-cn">Send and Receive Messages <cn>发送和接收消息</cn></a>
<ul>
<li><a href="#frames-cn-帧-cn">Frames <cn>帧</cn></a></li>
</ul></li>
<li><a href="#control-frames-cn-控制帧-cn">Control Frames <cn>控制帧</cn></a>
<ul>
<li><a href="#control-callback-cn-控制回调-cn">Control Callback <cn>控制回调</cn></a></li>
<li><a href="#close-frames-cn-关闭帧-cn">Close Frames <cn>关闭帧</cn></a></li>
<li><a href="#auto-fragment-cn-自动分段-cn">Auto-fragment <cn>自动分段</cn></a></li>
</ul></li>
<li><a href="#teardown-cn-拆解-cn">Teardown <cn>拆解</cn></a>
<ul>
<li><a href="#user-defined-teardown-cn-用户定义的拆解-cn">User-defined Teardown <cn>用户定义的拆解</cn></a></li>
<li><a href="#invoking-teardown-cn-调用拆解-cn">Invoking Teardown <cn>调用拆解</cn></a></li>
</ul></li>
<li><a href="#notes-cn-提示-cn">Notes <cn>提示</cn></a>
<ul>
<li><a href="#asynchronous-operations-cn-异步操作-cn">Asynchronous Operations <cn>异步操作</cn></a></li>
<li><a href="#the-io-context">The io_context</a></li>
<li><a href="#thread-safety-cn-线程安全-cn">Thread Safety <cn>线程安全</cn></a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">相關內容</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/post/translate_n4286/">翻译协议n4286</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-blue bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://muliao.github.io" >
    &copy; 2019 Muliao&#39;s Blog
  </a>
    <div>











</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
